#version 450

#include "../vars.h"

layout(local_size_x = 1, local_size_y = 1) in;
// x:height y:grid-x z:grid-y
layout(binding = 0, rgba32f) uniform image2D img0;      // advect(0)---- [img0] <--update_velocity(2)
layout(binding = 1, rgba32f) uniform image2D img1;      //    |                            |
layout(binding = 2, rgba32f) uniform image2D img2;      //    â†“                            |
layout(binding = 3, rg16f) uniform image2D normalImg;   // [img1] --update_height(1)--> [img2] -(2)-> [normalImg]
layout(std140, binding = 4) uniform UniformBufferObject {
    int stage;
} ubo;

void main() {
    const float depth = -1.0;
    const float dt = 0.08;
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);

    // img1 -> img2: update height
    if (ubo.stage == 1) {
        vec4 p = imageLoad(img1, xy);
        vec4 pxn = imageLoad(img1, ivec2(xy.x + 1, xy.y));
        vec4 pyn = imageLoad(img1, ivec2(xy.x, xy.y + 1));
        p.x -= depth; pxn.x -= depth; pyn.x -= depth;
        p.x -= p.x * ((pxn.y - p.y + pyn.z - p.z)) * dt;
        p.x += depth;
        imageStore(img2, xy, p);
    }

    // img0 -> img1: advect
    if (ubo.stage == 0) {
        vec4 p = imageLoad(img0, xy);
        //TODO optional advection
        imageStore(img1, xy, p);
    }

    // img2 -> img0: update velocity
    //TODO consider bathymetry
    if (ubo.stage == 2) {
        vec4 p = imageLoad(img2, xy);
        vec4 pxn = imageLoad(img2, ivec2(xy.x - 1, xy.y));
        vec4 pyn = imageLoad(img2, ivec2(xy.x, xy.y - 1));
        // img2 -> normal
        imageStore(normalImg, xy, vec4((p.x - pxn.x) * 50, (p.x - pyn.x) * 50, 0, 0));
        p.x -= depth; pxn.x -= depth; pyn.x -= depth;
        p.y += 9.8 * ((pxn.x - p.x)) * dt;
        p.z += 9.8 * ((pyn.x - p.x)) * dt;
        p.x += depth;
        imageStore(img0, xy, p);
    }
}
